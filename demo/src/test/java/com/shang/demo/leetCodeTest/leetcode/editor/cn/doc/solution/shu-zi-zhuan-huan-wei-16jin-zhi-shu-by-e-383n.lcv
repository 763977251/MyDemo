# 在做这个题之前，我们先明确几个概念：

## 一、进制之间如何相互转换？十进制数如何转换为其他进制？

#### 以23转换为2进制为例：

23除以2等于11余数为1.

11除以2等于5余数为1.

5除以2等于2余数为1.

2除以2等于1余数为0.

1除以2等于0余数为1.

### 由下往上，23的二进制表示为10111.

同样，转换为16进制我们也可以采取同样的短除法。

下面以29为例。

### 29除以16等于1余数为13（表示16进制为d）

1除以16等于0余数为1.

### 所以29的十六进制表示为1d.

# 二、计算机中的负数是余码表示的，如何采取上述方法达到一样的效果？

### 显然，对于正数，短除法是完全可行的，但对于负数，我们就必须清楚一个补码与原码的转换。

### 下面以-1为例子：

在计算机中，32位2进制数-1的表示为11111111111111111111111111111111（余码）。

若将11111111111111111111111111111111当为原码看待，不难看出它等于2^32-1.

## 事实上，对与任意负数x，若想得出其n位补码表示的实际数值，公式为2^n+x.

得到以上两个基本结论后，我们再来看代码。

## 

&#x20; &#x20;

* c

```c


char * toHex(int num){
    
    char* res=(char*)malloc(sizeof(char)*10);//先准备好将要存储答案的字符指针。
    int k=0;//声明res的下标。
    if(num==0)res[k]='0',k++;//边界情况处理，若num=0，直接将res[0]赋值为’0’.
    
    char hex[16]="0123456789abcdef";//将16进制下的单个数表示存在一个字符数组中方便取用。
    
    long long NUM=num;//声明一个64位的整形存储num的值，防止补码转换时溢出。
    if(num<0)NUM=pow(2,32)+num;//如果num为负数，NUM=2^32+num.
    
    int tmp[10];//声明一个备用tmp数组，存储短除法每一步的余数。
    int i=0;//声明tmp的下标。
    while(NUM!=0)//如果NUM不等于0（即短除法结束条件）
    {
        tmp[i++]=NUM%16;//将每一步余数存入tmp数组中。
        NUM/=16;//NUM自身除以16.
    }
    
    for(int j=i-1;j>=0;j--)res[k++]=hex[tmp[j]];//由于短除法是自下而上得出结果，所以此时tmp数组中的余数需要倒置，同时转换成hex中对应的十六进制数表示。
    res[k]='\0';//在字符串末尾存入’\0’表示字符串结束，扫尾。
    
    return res;//返回结果。
}
```

