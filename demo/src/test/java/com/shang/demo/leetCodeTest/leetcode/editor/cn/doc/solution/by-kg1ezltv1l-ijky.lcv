### æ€è·¯

é€šå¸¸æ ‘çš„éåŽ†æ–¹å¼æœ‰å¦‚ä¸‹å‡ ç§(å¾ˆå¥½è®°, å¯ä»¥ç”¨ **`ä¸­`** çš„ä½ç½®æ¥åšæ ‡è®°)
1. å‰åºéåŽ†: **`ä¸­å·¦å³`**
2. ä¸­åºéåŽ†: **`å·¦ä¸­å³`**
3. åŽåºéåŽ†: **`å·¦å³ä¸­`**

é¢˜ç›®è¦æ±‚ç”±å‰åºéåŽ†å’Œä¸­åºéåŽ†å¾—å‡ºæ ‘çš„ç»“æž„ã€‚å‰åºéåŽ†é¡ºåºä¸º **`ä¸­å·¦å³`** å¯å¾—çŸ¥ **`ç¬¬ä¸€ä¸ªä½ç½®`** æ˜¯æ ¹èŠ‚ç‚¹ï¼Œæˆ‘ä»¬æ‰¾åˆ°æ ¹èŠ‚ç‚¹åŽé‚£ä¹ˆå¶å­èŠ‚ç‚¹æˆ‘ä»¬å¯ä»¥ä»Žä¸­åºéåŽ†(**`å·¦ä¸­å³`**)ä¸­å¾—å‡ºåœ¨æ ¹èŠ‚ç‚¹çš„ä¸¤ä¾§ã€‚å› æ­¤æˆ‘ä»¬å¯ä»¥å¾—å‡ºå½“å‰æ ¹èŠ‚ç‚¹å·¦å³å­æ ‘èŠ‚ç‚¹åˆ°åº•æœ‰å“ªäº›ã€‚æŒ‰ç…§ä¸Šè¿°æ¡ä»¶æˆ‘ä»¬å¯ä»¥é€šè¿‡é€’å½’æ¥è¿›è¡Œå»ºæ ‘äº†ã€‚

### ä¸¾ä¸€ä¸ªðŸŒ° å§ï½ž

å°±é¢˜ç›®çš„ä¾‹å­ï¼Œå·²çŸ¥å‰åºéåŽ†ä¸º **`[3, 9, 20, 15, 7]`**ï¼Œä¸­åºéåŽ†ä¸º **`[9, 3, 15, 20, 7]`**.
1. ç”±å‰åº **`[3, 9, 20, 15, 7]`** æˆ‘ä»¬å¯ä»¥çŸ¥é“æ ¹èŠ‚ç‚¹ä¸º **`3`**ï¼Œé€šè¿‡ä¸­åºéåŽ† **`[9, 3, 15, 20, 7]`** å¯ä»¥å¾—å‡º **`3`** çš„å·¦å­æ ‘ä¸º **`[9]`**ã€å³å­æ ‘ä¸º **`[15, 20, 7]`**ã€‚
2. å‰åºéåŽ†å°±å¯ä»¥åˆ’åˆ†ä¸º **`[3, [9], [20, 15, 7]]`**ï¼Œæˆ‘ä»¬å¯ä»¥è®¡ç®—å‡ºå·¦å­æ ‘ **`[9]`** çš„æ ¹èŠ‚ç‚¹ä¸º **`9`**ï¼Œå³å­æ ‘ **`[20, 15, 7]`** çš„æ ¹èŠ‚ç‚¹ä¸º **`20`**ã€‚
3. æž„å»º **`3`** çš„å·¦å­æ ‘ï¼Œç”±ä¸­åºéåŽ† **`[9]`** å¯ä»¥çœ‹å‡ºåªæœ‰å½“ä¸€èŠ‚ç‚¹ï¼Œæž„å»ºå¶å­ç»“ç‚¹å¹¶è¿”å›žã€‚
4. æž„å»º **`3`** çš„å³å­æ ‘ï¼Œé€šè¿‡ä¸­åºéåŽ† **`[15, 20, 7]`** å¯ä»¥å¾—å‡º **`20`** çš„å·¦å­æ ‘ä¸º **`[15]`**ã€å³å­æ ‘ä¸º **`[7]`**ã€‚
5. å‰åºéåŽ†å°±å¯ä»¥åˆ’åˆ†ä¸º **`[20, [15], [7]]`**ï¼Œæˆ‘ä»¬å¯ä»¥è®¡ç®—å‡ºå·¦å­æ ‘ **`[15]`** çš„æ ¹èŠ‚ç‚¹ä¸º **`15`**ï¼Œå³å­æ ‘ **`[7]`** çš„æ ¹èŠ‚ç‚¹ä¸º **`7`**ã€‚
6. æž„å»º **`20`** çš„å·¦å­æ ‘ï¼Œç”±äºŽç”±ä¸­åºéåŽ† **`[15]`** å¯ä»¥çœ‹å‡ºåªæœ‰å½“ä¸€èŠ‚ç‚¹ï¼Œæž„å»ºå¶å­ç»“ç‚¹å¹¶è¿”å›žã€‚
7. æž„å»º **`20`** çš„å³å­æ ‘ï¼Œç”±äºŽç”±ä¸­åºéåŽ† **`[7]`** å¯ä»¥çœ‹å‡ºåªæœ‰å½“ä¸€èŠ‚ç‚¹ï¼Œæž„å»ºå¶å­ç»“ç‚¹å¹¶è¿”å›žã€‚
8. æž„å»ºæµç¨‹ç»“æŸã€‚

### å®žçŽ°ä»£ç å¦‚ä¸‹

* javascript

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function(preorder, inorder) {
    function TreeNode(val) {
      this.val = val;
      this.left = this.right = null;
    }
    const dfs = (index, arr) => {
        if (index < preorder.length) {
            const targetVal = preorder[index];
            const newRoot = new TreeNode(targetVal);
            const targetIndex = arr.indexOf(targetVal);
            if (targetIndex !== -1) {
                const leftArr = arr.slice(0, targetIndex);
                newRoot.left = dfs(index + 1, leftArr);
                const rightArr = arr.slice(targetIndex + 1);
                newRoot.right = dfs(index + leftArr.length + 1, rightArr);
                return newRoot;
            }
        }
        return null;
    }
    return dfs(0, inorder);
};
```

![image.png](https://pic.leetcode-cn.com/1650809564-iWQIRH-image.png)
