### å‰è¨€

> æˆ‘ä¸ªäººè®¤ä¸ºé€’å½’çš„æ€è·¯æ¥å†™è¿™ä¸€é¢˜æ˜¯å¾ˆæ¸…æ™°ä¸”æ˜“æ‡‚çš„ï¼Œæˆ‘ä»¬åªéœ€è¦ä»”ç»†çš„è€ƒè™‘è¾¹ç•Œçš„é—®é¢˜å³å¯ã€‚

&emsp;&emsp;è¿™ä¸€é¢˜æ˜¯ â€œä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘â€ å¯¹åº”çš„è¿˜æœ‰ä¸€é¢˜æ˜¯[106. ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)ã€‚è¿™ä¸¤ä¸ªé¢˜çš„æ€è·¯éƒ½æ˜¯ä¸€æ ·çš„ï¼Œæ¢æ±¤ä¸æ¢è¯ï¼Œåšå®Œè¿™ä¸ªé¢˜ä¹‹åï¼Œå¤§å®¶å»åšåšå¦ä¸€ä¸ªï¼Œçœ‹çœ‹è‡ªå·±æŒæ¡çš„æ€ä¹ˆæ ·ã€‚

### æ€è·¯åˆ†æ

![image.png](https://pic.leetcode-cn.com/1647483105-OJDiCZ-image.png)

&emsp;&emsp; æˆ‘ç”»äº†ä¸€å¼ å›¾ï¼Œå¤§å®¶å¯¹ç…§è¿™å¼ å›¾æ¥çœ‹ã€‚è¿™ä¸€é¢˜ä»–ç»™äº†æˆ‘ä»¬ä¸¤ä¸ªæ•°ç»„ï¼Œä¸€ä¸ªæ˜¯å‰åºéå†ã€å¦ä¸€ä¸ªæ˜¯ä¸­åºéå†ï¼Œæˆ‘ä»¬è¦æƒ³æ„é€ ä¸€ä¸ªæ ‘æˆ‘ä»¬å¿…é¡»æ‰¾åˆ°ä»–çš„å¤´èŠ‚ç‚¹å¯¹å§ã€‚æ˜¾ç„¶ï¼Œ`å‰åºéå†çš„ç¬¬ä¸€ä¸ªå…ƒç´ `å°±æ˜¯ä»–çš„å¤´èŠ‚ç‚¹ã€‚çŸ¥é“äº†å¤´èŠ‚ç‚¹ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ä¸­åºéå†ä¸­æ‰¾åˆ°å¤´èŠ‚ç‚¹çš„ä½ç½®`index`ã€‚çŸ¥é“äº†è¿™äº›ä¿¡æ¯æˆ‘ä»¬å°±å¯ä»¥æ±‚å‡ºæ¥å·¦å­æ ‘åœ¨æ•°ç»„ä¸­çš„é•¿åº¦ï¼š `index - inoStart`ã€‚ï¼ˆinoStart æ˜¯ä¸­åºéå†çš„èµ·ç‚¹ï¼‰ã€‚
&emsp;&emsp;çŸ¥é“äº†ä¸Šé¢çš„ä¿¡æ¯æˆ‘ä»¬å¼€å§‹æ„å»ºäºŒå‰æ ‘ï¼š
1. è·å–æ ‘çš„å¤´èŠ‚ç‚¹ `int val =  preorder[preStart]` (preStartæ˜¯å‰åºéå†çš„èµ·å§‹å€¼)ã€‚ç„¶åæˆ‘ä»¬ç›´æ¥æ„å»ºäºŒå‰æ ‘ `TreeNode root = new TreeNode(val)`
2. æ„å»ºå·¦æ ‘ï¼š`root.left` æˆ‘ä»¬çŸ¥é“è¯¥äºŒå‰æ ‘çš„å·¦å­æ ‘çš„é•¿åº¦ä¸º `int leftSize = index - inoStart;`
   - æ‰€ä»¥æˆ‘ä»¬å¯ä»¥æ¨å‡ºäºŒå‰æ ‘çš„å·¦å­æ ‘åœ¨`å‰åºéå†`çš„ä½ç½®æ˜¯`[preStart + 1 ï¼ŒpreStart + leftSize]`ã€‚
   - åŒç†ï¼šäºŒå‰æ ‘çš„å·¦å­æ ‘åœ¨`ä¸­åºéå†`çš„ä½ç½®æ˜¯`[inoStart , index - 1]`ã€‚
3. æ„å»ºå³æ ‘ï¼š`root.right`
   - äºŒå‰æ ‘çš„å³å­æ ‘åœ¨`å‰åºéå†`çš„ä½ç½®æ˜¯` [preStart + leftSize + 1,preEnd]`ã€‚
   - åŒç†ï¼šäºŒå‰æ ‘å³å­æ ‘åœ¨`ä¸­åºéå†`çš„ä½ç½®æ˜¯`[index + 1 , inoEnd]`ã€‚
     ä»£ç å¦‚ä¸‹ï¼šğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡

### ä»£ç 

* java

```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return build(preorder,inorder,0,preorder.length - 1,0,inorder.length - 1);
    }
    TreeNode build(int[] preorder, int[] inorder,int preStart,int preEnd,int inoStart,int inoEnd){
        //base case
        if(preStart > preEnd || inoStart > inoEnd){
            return null;
        }
        //æ ‘çš„æ ¹èŠ‚ç‚¹
        int val = preorder[preStart];
        TreeNode root =  new TreeNode(val);
        //æŸ¥æ‰¾æ ¹èŠ‚ç‚¹åœ¨ä¸­åºéå†çš„ä½ç½®
        int index = 0; 
        for(int i = inoStart;i <= inoEnd;i++){
            if(inorder[i] == val){
                index = i;
                break;
            }
        }
        //è®¡ç®—å·¦å­æ ‘åœ¨æ•°ç»„ä¸­çš„é•¿åº¦
        int leftSize = index - inoStart;
        //é€’å½’æ„å»ºã€‚
        root.left = build(preorder,inorder,preStart + 1,preStart + leftSize,inoStart , index - 1);
        root.right = build(preorder,inorder,preStart + leftSize + 1,preEnd,index + 1 , inoEnd);
        return root;
    }
}
```

